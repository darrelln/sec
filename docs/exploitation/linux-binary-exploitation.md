---
layout: default
title: Linux Binary Exploitation
parent: EXPLOITATION
has_children: false
has_toc: false
---

{% include toc.html %}

*This isn't intended as a tutorial for others, only a reminder to me. As such it's likely to be incomplete.*

## References

[GDB Tutorial](https://web.eecs.umich.edu/~sugih/pointers/summary.html)
[Peda](https://github.com/longld/peda)
[GDB](https://visualgdb.com/gdbreference/commands/)

## Basics
### Evaluating a binary

|Command|Description|
|:---|:---|
|`file`|Show file details.|
|`strings`|Show printable character sequences.|
|`readelf`|Show details for an `elf` file.|
|`ldd`|Show shared-object dependencies.|
|`binwalk`|Search for embedded files or executable code.|
|`checksec`|Show security measures.|
|`ltrace`|Trace library calls.|
|`strace`|Trace system calls.|
|`objdump`|Show disassembly.|
|`nm`|Show symbols.|
|'Ghidra`|Graphical disassembler.|


### Using checksec
This can be run from `GDB` or standalone. Output looks something like this:

![Output](images/check-sec.png)

## GDB Primer
To make GDB more user friendly (colourised output, additional functionality and commands), install `peda`:
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

### GDB Command Reference

|Command|Description|
|:---|:---|
|**Getting started**||
|`gdb`|Start `GDB` without spedifying a file (use the `file` command to load a file).|
|`gdb file-to-debug`|Start `GDB` using the file `file-to-debug`.|
|`clear`|Clear the screen.|
|`(q)uit`|Quit `GDB`.|
|**Running**||
|`(f)ile file-to-debug`|Specify the name of the file to debug.|
|`(r)un`|Start debugging the specified file.|
|`(r)un arg1 arg2`|Start debugging passing `arg1` and `arg2` to the executable.|
|`start`|Start debugging and break at the first convenient location (think `main`).|
|**Getting help**||
|`(h)elp`|Show the help menu.|
|`(h)elp breakpoints`|Show help for the `breakpoints` topic.|
|`(h)elp tbreak`|Show help for the `tbreak` command.|
|**Getting information**||
|`info breakpoints`|List breakpoints.|
|`info watchpoints`|List watchpoints.|
|`info address main`|Show the address of function `main`.|
|`info line main`|Show the line number of function `main` in the source file.|
|`info source`|Show details of the file being debugged.|
|`info frame`|Show the current stack frame (once breakpoint hit).|
|`info locals`|Show the values of locals (once breakpoint hit).|
|`info args`|Show the values of the passed args (once breakpoint hit).|
|**Debugging**||
|`info (b)reakpoints`|List set breakpoints.|
|`info watchpoints`|List set watchpoints.|
|`(b)reak`|Set breakpoint on the current line.|
|`(b)reak +2`|Set breakpoint 2 lines down from the current line.|
|`(b)reak main`|Set breakpoint on function `main`.|
|`(b)reak *0x555555555135`|Set breakpoint at memory location (note the `*`).|
|`(b)reak func_name if count == 5`|Conditional breakpoint.|
|`(del)ete`|Delete all breakpoints.|
|`(c)ontinue`|Continue execution after hitting a breakpoint.|
|`(s)tep`|Step to next line.|
|`(s)tep 3`|Execute the next 3 lines of code.|
|`watch param`|Watch parameter `param` and stop if it's value changes (break when modified).|
|`watch p->param`|Watch parameter `param` on object `p` and stop if it's value changes.|
|`watch $sp`|Watch register `$sp` and stop if it changes.|
|`bt` or `backtrace`|Show stack trace.|
|`bt full` or `backtrace full`|Show full stack trace.|
|**Examining registers**||
|`info registers`|Show register contents (`GDB`).|
|`xinfo registers`|Show register contents (`peda`).|
|`xinfo register SP`|Show contents of register `SP` (`peda`).|
|**Examining the stack**||
|`frame`|Show the current stack frame.|
|`frame 2`|Show stack frame 2.|
|`info frame`|Show details about the current stack frame.|
|`info frame 2`|Show details about stack frame 2.|
|`up`|Show the frame that called this one.|
|`down`|Show the frame called by this one.|
|**Examining memory**||
|`x`|Show memory at current location.|
|`x 0x555555555052`|Show memory at location `0x555555555052`.|
|`x/8w 0x555555555052`|Show 8 words of memory from location `0x555555555052`.|
|`x/8b 0x555555555052`|Show 8 bytes of memory from location `0x555555555052`.|
|`x/8wx 0x555555555052`|Show 8 words of memory in hex format from location `0x555555555052`.|
|**Disassembly**||
|`(disas)semble`|Show disassembly (break and then issue command, see reference for more).|
|`(disas)semble show_message`|Show disassembly for function `show_message`.|
|`(disas)semble 0x555555555135`|Show disassembly for function at address `0x555555555135`.|

### Peda Command Reference

|Command|Description|
|:---|:---|
|`aslr`|Check `aslr` status for the binary.|
|`checksec`|Check the security options for the binary.|
|`reg` or `xinfo registers`|Print registry information.|

## Return to libc / Return Oriented Programming (ROP)
When to use `return to libc`:
- Buffer causing overflow is too small for a `nop sled/shellcode` attack


Show memory location the binary resides at and also the `libc` addresses.
```
cat /proc/self/maps
```


Piping Python print into binary (use backticks or `$`). Wrap the command substitution in `"` to prevent `python` interrupretting raw bytes:
```
./overflow "`python3 -c "print('i' * 100)"`"
./overflow "$(python3 -c "print('i' * 100)")"
```
 
![hello-world.c](images/hello-world-dot-c.png)

 ```c
 // Compile with: gcc -g hello-world.c -o hello-world
 #include <stdio.h>

void show_message(const char* msg)
{
	printf("%s\n", msg);
}

int main(int argc, char const *argv[])
{
	const char* msg = "Hello, World";
	show_message(msg);
	return 0;
}
 ```