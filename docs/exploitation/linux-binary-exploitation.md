---
layout: default
title: Linux Binary Exploitation
parent: EXPLOITATION
has_children: false
has_toc: false
---

{% include toc.html %}

*This isn't intended as a tutorial for others, only a reminder to me. As such it's likely to be incomplete.*

## References

[GDB Tutorial](https://web.eecs.umich.edu/~sugih/pointers/summary.html)

[Peda](https://github.com/longld/peda)

[GDB](https://visualgdb.com/gdbreference/commands/)

[Stack Overflow Registers](https://stackoverflow.com/questions/25455447/x86-64-registers-rax-eax-ax-al-overwriting-full-register-contents)

[Registers](https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm)

[x64 Cheatsheet](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf)

[The Call Stack](https://en.wikipedia.org/wiki/Call_stack)

[x64 Instruction Set](https://en.wikipedia.org/wiki/X86_instruction_listings)

[The Zen of Assembly](https://www.jagregory.com/abrash-zen-of-asm/)

## Basics
### Evaluating a binary

|Command|Description|
|:---|:---|
|`file`|Show file details.|
|`strings`|Show printable character sequences.|
|`readelf`|Show details for an `elf` file.|
|`ldd`|Show shared-object dependencies.|
|`binwalk`|Search for embedded files or executable code.|
|`checksec`|Show security measures.|
|`ltrace`|Trace library calls.|
|`strace`|Trace system calls.|
|`objdump`|Show disassembly.|
|`nm`|Show symbols.|
|'Ghidra`|Graphical disassembler.|


### Using checksec
This can be run from `GDB` or standalone. Output looks something like this:

![Output](images/check-sec.png)

## GDB Primer
To make GDB more user friendly (colourised output, additional functionality and commands), install `peda`:
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

### GDB Command Reference

|Command|Description|
|:---|:---|
|**Getting started**||
|`gdb`|Start `GDB` without spedifying a file (use the `file` command to load a file).|
|`gdb file-to-debug`|Start `GDB` using the file `file-to-debug`.|
|`clear`|Clear the screen.|
|`(q)uit`|Quit `GDB`.|
|**Running**||
|`(f)ile file-to-debug`|Specify the name of the file to debug.|
|`(r)un`|Start debugging the specified file.|
|`(r)un arg1 arg2`|Start debugging passing `arg1` and `arg2` to the executable.|
|`start`|Start debugging and break at the first convenient location (think `main`).|
|`show args`|Show the arguments the debug session started with.|
|`set args`|Clear cached arguments (sets them to empty and will cache empty args for future starts until changed).|
|`kill`|Kill the active debug session.|
|**Getting help**||
|`(h)elp`|Show the help menu.|
|`(h)elp breakpoints`|Show help for the `breakpoints` topic.|
|`(h)elp tbreak`|Show help for the `tbreak` command.|
|**Getting information**||
|`info breakpoints`|List breakpoints.|
|`info watchpoints`|List watchpoints.|
|`info address main`|Show the address of function `main`.|
|`info line main`|Show the line number of function `main` in the source file.|
|`info func`|Show the binary's function definitions.|
|`info source`|Show details of the file being debugged.|
|`info frame`|Show the current stack frame (once breakpoint hit).|
|`info locals`|Show the values of locals (once breakpoint hit).|
|`info args`|Show the values of the passed args (once breakpoint hit).|
|**Debugging**||
|`info (b)reakpoints`|List set breakpoints.|
|`info watchpoints`|List set watchpoints.|
|`(b)reak`|Set breakpoint on the current line.|
|`(b)reak +2`|Set breakpoint 2 lines down from the current line.|
|`(b)reak main`|Set breakpoint on function `main`.|
|`(b)reak *main+51`|Set breakpoint at memory address `main+51` (51 bytes from the start of `main`).|
|`(b)reak *0x555555555135`|Set breakpoint at memory location (note the `*`).|
|`(b)reak func_name if count == 5`|Conditional breakpoint.|
|`(del)ete`|Delete all breakpoints.|
|`(c)ontinue`|Continue execution after hitting a breakpoint.|
|`(s)tep`|Step to next line.|
|`(s)tep 3`|Execute the next 3 lines of code.|
|`layout next`|Show source code (assuming binary compiled with `-g`).|
|`layout src`|Show source code (assuming binary compiled with `-g`).|
|`Ctrl+x, a`|Hide source code TUI window.|
|`(n)ext`|Run next instruction.|
|`watch param`|Watch parameter `param` and stop if it's value changes (break when modified).|
|`watch p->param`|Watch parameter `param` on object `p` and stop if it's value changes.|
|`watch $sp`|Watch register `$sp` and stop if it changes.|
|`bt` or `backtrace`|Show stack trace.|
|`bt full` or `backtrace full`|Show full stack trace.|
|**Examining registers**||
|`info registers`|Show register contents (`GDB`).|
|`xinfo registers`|Show register contents (`peda`).|
|`xinfo register SP`|Show contents of register `SP` (`peda`).|
|**Examining the stack**||
|`frame`|Show the current stack frame.|
|`frame 2`|Show stack frame 2.|
|`info frame`|Show details about the current stack frame.|
|`info frame 2`|Show details about stack frame 2.|
|`up`|Show the frame that called this one.|
|`down`|Show the frame called by this one.|
|**Examining memory**||
|`x`|Show memory at current location.|
|`x/i`|Show current instruction.|
|`x 0x555555555052`|Show memory at location `0x555555555052`.|
|`x/8w 0x555555555052`|Show 8 words of memory from location `0x555555555052`.|
|`x/8b 0x555555555052`|Show 8 bytes of memory from location `0x555555555052`.|
|`x/8wx 0x555555555052`|Show 8 words of memory in hex format from location `0x555555555052`.|
|`x/20x $esp`|Show 20 hex values from the address stored in the `esp` register.|
|**Disassembly**||
|`(disas)semble`|Show disassembly (break and then issue command, see reference for more).|
|`(disas)semble show_message`|Show disassembly for function `show_message`.|
|`(disas)semble 0x555555555135`|Show disassembly for function at address `0x555555555135`.|

### Peda Command Reference

|Command|Description|
|:---|:---|
|`aslr`|Check `aslr` status for the binary.|
|`checksec`|Check the security options for the binary.|
|`reg` or `xinfo registers`|Print registry information.|

## Registers
### Register format for x86_64
Registers starting with `R`, i.e. `RAX`, `R12` are 64-bit registers. These can then be broken down into small increments:
```c
RAX     // 64 bits / 8 bytes, bytes 0-7.
EAX     // 32 bits / 4 bytes, bytes 0-3.
AX      // 16 bits / 2 bytes, bytes 0-1.
AH      // 8 bits / 1 byte (higher), byte 1.
AL      // 8 bites / 1 byte (lower), byte 0.

// This looks something like this:
  ================ RAX (64 bits)
          ======== EAX (32 bits)
              ====  AX (16 bits)
              ==    AH (8 bits)
                ==  AL (8 bits)

See: https://stackoverflow.com/questions/25455447/x86-64-registers-rax-eax-ax-al-overwriting-full-register-contents
```

### Register reference

|Name|Usage|
|:---|:---|
|`AX`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|Accumulator register, used for arethmetic operations.|
|`BX`|Base registers (not base pointer) used for indexed addressing.|
|`CX`|Count register, used for loop counters.|
|`DX`|Data register, used in combination with `AX`.|
|`SI`|Source Index register, |
|`DI`|Destination Index register, |
|`BP`|Base pointer, constant address pointing to the bottom of the stack used with offset to access variables pushed to the stack. Variables on the stack are at an address offset from the `BP` register value. Return address with be `rbp+4`, first argument `rbp+8`, first local variable at `rbp-4`.|
|`SP`|Stack pointer, points to the top of the stack (next available address on the stack) so moves up and down.|
|`IP`|Instruction pointer, contains the address of the next instruction to be executed. Not directly controllable, |
|`R8-R15`|General purpose registers.|

### Assembler reference

|Instruction|Description|
|:---|:---|
|**Set up a stack frame**||
|`push rbp`|Push contents of the base pointer `rbp` to the stack.|
|`mov rbp, rsp`|Move the contents of `rsp` into `rbp`.|
|**Reserve 48 bytes on the stack for arguments**||
|`sub rsp, 0x30`||
|**Move arguments onto the stack**||
|`mov DWORD PTR [rbp-0x24],edi`|First 6 arguments are passed via registers.|
|`mov QWORD PTR [rbp-0x30],rsi`|First 6 arguments are passed via registers.|
|**Load effective address**||
|`lea rax,[rip+0xe83]`|Load the effective address resulting from `[rip+0xe83]` into rax for use by the next instruction. The `lea` insttuction calculates a memory address but does not address memory directly, hence it calculating a memory address for use by the next instruction.|
|`mov QWORD PTR [rbp-0x8],rax`||
|**Calling functions**||
|`call 0x555555555135 <show_message>`||
|``||
|``||
|``||
|``||
|``||

## Return to libc / Return Oriented Programming (ROP)
When to use `return to libc`:
- Buffer causing overflow is too small for a `nop sled/shellcode` attack


Show memory location the binary resides at and also the `libc` addresses.
```
cat /proc/self/maps
```


Piping Python print into binary (use backticks or `$`). Wrap the command substitution in `"` to prevent `python` interrupretting raw bytes:
```
./overflow "`python3 -c "print('i' * 100)"`"
./overflow "$(python3 -c "print('i' * 100)")"
```
 
![hello-world.c](images/hello-world-dot-c.png)

 ```c
 // Compile with: gcc -g hello-world.c -o hello-world
 #include <stdio.h>

void show_message(const char* msg)
{
	printf("%s\n", msg);
}

int main(int argc, char const *argv[])
{
	const char* msg = "Hello, World";
	show_message(msg);
	return 0;
}
 ```